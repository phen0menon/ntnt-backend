## Установка и запуск

1. Убедиться в том, что поднят Redis сервер на порте `6379` - нужен для работы с WebSocket
2. `$ yarn` - для установки зависимостей
3. Запуск:
   - `$ yarn start:dev` - для запуска в dev-режиме
   - `$ yarn start:prod` - для запуска в prod-режиме

## Что можно улучшить / изменить:

- Поскольку у нас небольшая задача, заключаящаяся в том, чтобы отдавать клиенту актуальные измененные статусы для пула операций, мы можем попробовать реализовать очередь выдачи результатов с помощью LongPoll. Общий флоу такой:
  1. Клиент посылает запрос на создание операции
  2. Клиент каждые N секунд должен посылать запрос на получение изменений (по истечении N секунд запрос прерывается и создается новый). Сервер в это время задерживает этот запрос пока очередь операций на выдачу пуста. Как только появляется элемент - извлекаем его и отдаем клиенту ответ.
- Текущее решение через jobs + sockets кажется также хорошим и надежным решением.
- Можно также использовать брокеры сообщений в случае большой нагрузки.
- Пытался воспроизвести эту логику без запуска job-а в сервисе, а с помощью typeorm entity listeners - при `afterInsert` создавать новый job на изменение нужной `Operation`. Не получилось заинжектить нужные зависимости, поэтому бросил это дело, да и кажется не особо хорошим вариантом.
- Возможно есть более красивый способ работы с job-ами :)
- Возможно есть более хорошие практики структурирования проекта на NestJS, но т.к это тестовое, - не заморачивался.
- Хорошо бы использовать конфигурационный модуль, но т.к здесь не так уж и много переменных, решил не делать. На реальном проекте естественно это будет необходимо
